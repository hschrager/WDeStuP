/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Tue Dec 07 2021 18:56:38 GMT+0000 (Coordinated Universal Time).
 */

define(['jointjs', 'css!./styles/PNWidgetWidget.css'], function (joint) {
    'use strict';

    var WIDGET_CLASS = 'p-n-widget';

    function PNWidgetWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    PNWidgetWidget.prototype._initialize = function () {
        console.log(joint);
        
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        // Create a dummy header
        this._jointPN = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
             el: this._el,
             width : width,
             height: height,
             model: this._jointPN,
             interactive: false
        });

        // add event calls to elements
        this._jointPaper.on('element:pointerdblclick', function(elementView) {
            const currentElement = elementView.model;
            if (self._webgmePN) {
                self._setCurrentState(self._webgmePN.id2node[currentElement.id]);
            }
            if (!self._webgmePN.nodes[self._webgmePN.id2node[currentElement.id]].isPlace){
                self.fireEvent(currentElement);
            }
        });
        this._webgmePN = null;
    };

    PNWidgetWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };


    // State Machine manipulating functions called from the controller
    PNWidgetWidget.prototype.initPetriNet = function (pnDescriptor) {
        const self = this;
        console.log(pnDescriptor);

        self._webgmePN = pnDescriptor;
        // self._webgmePN.current = self._webgmePN.init_markings;
        self._jointPN.clear();
        
        const pn = self._webgmePN;
        pn.id2node = {}; // this dictionary will connect the on-screen id to the state id
        // first add the states
        // instead of states this will be places and transitions for miniproject
        //      also have arcs for connections
        // go through all 3 lists 
        // include number of markings in this forEach loop 
            // marking = list of places with the number of tokens on each place
        
        Object.keys(pn.nodes).forEach(nodeId => {
            let vertex = null;
            // confused here on how to differentiate between place and transition? 
            if (pn.nodes[nodeId].isPlace){
                vertex = new joint.shapes.standard.Circle({
                    position: pn.nodes[nodeId].position,
                    size: { width: 35, height: 35 },
                    attrs: {
                        body: {
                            fill: '#FFFFFF',
                            strokeWidth: 3,
                            cursor: 'pointer'
                        },
                        marking: pn.nodes[nodeId].numMarkings,
                        text: {
                            text: pn.nodes[nodeId].numMarkings,
                            fontWeight: 'bold'
                        }
                    },
                });
            } else {
                vertex = new joint.shapes.standard.Rectangle({
                    position: pn.nodes[nodeId].position,
                    size: { width: 22, height: 44 },
                    attrs: {
                        body: {
                            fill: '#FFFFFF',
                            strokeWidth: 3,
                            cursor: 'pointer'
                        },
                        // marking:  pn.nodes[nodeId].numMarkings
                    }
                });
            }
            vertex.addTo(self._jointPN); //add vertex to graph
            pn.nodes[nodeId].joint = vertex; 
            pn.id2node[vertex.id] = nodeId;
        });

        // then create the links
        //connecting two shapes 
        Object.keys(pn.nodes).forEach(nodeId => {
            const node = pn.nodes[nodeId];
            Object.keys(node.outgoing).forEach(event => {
                node.jointNext = node.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    //will only need source and target (not attributes and labels)
                    source: {id: node.joint.id},
                    target: {id: pn.nodes[node.outgoing[event]].joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                    }]
                });
                link.addTo(self._jointPN);
                node.jointNext[event] = link;
            })
        });

        //now refresh the visualization
        self._jointPaper.updateViews();
        self._decoratePetriNet();
    };

    PNWidgetWidget.prototype.destroyPetriNet = function () {

    };

    PNWidgetWidget.prototype.fireEvent = function (event) { 
        const self = this;

        const currTransition = self._webgmePN.nodes[self._webgmePN.id2node[event.id]];
        let allIncomingPlaces = [];
        //array to find all incoming places to the transition
        Object.keys(self._webgmePN.nodes).forEach(nodeId => {
            const node = self._webgmePN.nodes[nodeId];
            if (node.outgoing.includes(self._webgmePN.id2node[event.id])){
                allIncomingPlaces.push(node);
            }
        });
        //if there are no incoming places
        if (allIncomingPlaces.length == 0){
            console.log("no incoming places to make a transition.");
            return;
        }
        let enough_tokens = true;
        //for every incoming place
        allIncomingPlaces.forEach(place => {
            //check to make sure each place has a token
            if (place.numMarkings < 1){
                enough_tokens = false;
                this._logger.error("cannot fire this transition");
                return;
            } 
        });

        if (enough_tokens){
            allIncomingPlaces.forEach(place => {
                //decrement token count at each incoming place
                place.numMarkings--;
            });
            currTransition.outgoing.forEach(outgoing_place => {
                //increment token count at all outgoing places
                let outgoing_place_asnode = self._webgmePN.nodes[outgoing_place];
                outgoing_place_asnode.numMarkings++;
            })
            //redecorate petri net
            self._decoratePetriNet();    
        }
        
    };
    // will have similar function to ^^ to change the marking
        //pass in the ID of the transition to be fired, check all the incoming places, subtract one token, and add one token to all the outgoing places
        
    // after each fire event, when decorate machine for ex is called, all that's needed to do is change the color of the transition that is firing
    // calling deocrateMachine in each fireEvent
    // in the handling of the click, you want to decide whether you can actually make that transition

    //also need to use resetMachine function 
        // want to store the initial marking and reset the machine this way

    // create descriptor for how you want this to work

    // after fire event is called and the objects are initialized, need to check which nodes are fireable

    PNWidgetWidget.prototype.resetPetriNet = function () {
        Object.keys(this._webgmePN.nodes).forEach(nodeId => {
            const node = this._webgmePN.nodes[nodeId];
            if (node.isPlace) {
                node.numMarkings = this._webgmePN.init_markings[nodeId];
            }
        });
        this._decoratePetriNet();
    };

    PNWidgetWidget.prototype._decoratePetriNet = function() {
        const pn = this._webgmePN;
        Object.keys(pn.nodes).forEach(nodeId => {
            if (pn.nodes[nodeId].isPlace){
                pn.nodes[nodeId].joint.attr('text/text', pn.nodes[nodeId].numMarkings);
                pn.nodes[nodeId].joint.attr('body/stroke', 'black');
            } else {
                pn.nodes[nodeId].joint.attr('body/stroke', 'gray');
            }
            
        });
    };

    PNWidgetWidget.prototype._setCurrentState = function(newCurrent) {
        this._webgmePN.current = newCurrent;
        this._decoratePetriNet();
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    
    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    PNWidgetWidget.prototype.destroy = function () {
    };

    PNWidgetWidget.prototype.onActivate = function () {
        this._logger.debug('PNWidgetWidget has been activated');
    };

    PNWidgetWidget.prototype.onDeactivate = function () {
        this._logger.debug('PNWidgetWidget has been deactivated');
    };

    return PNWidgetWidget;
});
