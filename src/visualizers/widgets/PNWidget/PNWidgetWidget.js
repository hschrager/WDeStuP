/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Tue Dec 07 2021 18:56:38 GMT+0000 (Coordinated Universal Time).
 */

define(['jointjs', 'css!./styles/PNWidgetWidget.css'], function (joint) {
    'use strict';

    var WIDGET_CLASS = 'p-n-widget';

    function PNWidgetWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    PNWidgetWidget.prototype._initialize = function () {
        console.log("JOINT");
        console.log(joint);

        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        // Create a dummy header
        this._jointPN = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
             el: this._el,
             width : width,
             height: height,
             model: this._jointPN,
             interactive: false
        });

        // add event calls to elements
        this._jointPaper.on('element:pointerdblclick', function(elementView) {
            const currentElement = elementView.model;
            // console.log(currentElement);
            if (self._webgmePN) {
                // console.log(self._webgmeSM.id2state[currentElement.id]);
                self._setCurrentState(self._webgmePN.id2node[currentElement.id]);
            }
        });
        this._webgmePN = null;
    };

    PNWidgetWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };


    // State Machine manipulating functions called from the controller
    PNWidgetWidget.prototype.initPetriNet = function (machineDescriptor) {
        const self = this;
        console.log(machineDescriptor);

        self._webgmePN = machineDescriptor;
        self._webgmePN.current = self._webgmePN.init;
        self._jointPN.clear();
        
        const pn = self._webgmePN;
        pn.id2node = {}; // this dictionary will connect the on-screen id to the state id
        // first add the states
        // instead of states this will be places and transitions for miniproject
        //      also have arcs for connections
        // go through all 3 lists 
        // include number of markings in this forEach loop 
            // marking = list of places with the number of tokens on each place
        
        Object.keys(pn.nodes).forEach(nodeId => {
            let vertex = null;
            // confused here on how to differentiate between place and transition? 
            if (pn.nodes[nodeId].isPlace){
                vertex = new joint.shapes.standard.Circle({
                    position: pn.nodes[nodeId].position,
                    size: { width: 30, height: 30 },
                    attrs: {
                        body: {
                            fill: '#FFFFFF',
                            strokeWidth: 3,
                            cursor: 'pointer'
                        },
                        marking:  pn.nodes[nodeId].marking
                    }
                });
                // console.log("MARKINGS:");
                // console.log(vertex.attrs);
            } else {
                vertex = new joint.shapes.standard.Rectangle({
                    position: pn.nodes[nodeId].position,
                    size: { width: 20, height: 40 },
                    attrs: {
                        body: {
                            fill: '#000000',
                            strokeWidth: 3,
                            cursor: 'pointer'
                        },
                        marking:  pn.nodes[nodeId].marking
                    }
                });
                // console.log("MARKINGS:");
                // console.log(vertex.attrs.marking);
            }
            vertex.addTo(self._jointPN); //add vertex to graph
            pn.nodes[nodeId].joint = vertex; 
            pn.id2node[vertex.id] = nodeId;
        });
        //will do the same thing with transitions, but using different shape (square not circle)

        // then create the links
        //connecting two shapes 
        Object.keys(pn.nodes).forEach(nodeId => {
            const node = pn.nodes[nodeId];
            Object.keys(node.next).forEach(event => {
                node.jointNext = node.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    //will only need source and target (not attributes and labels)
                    source: {id: node.joint.id},
                    target: {id: pn.nodes[node.next[event]].joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                        attrs: {
                            text: {
                                text: event,
                                fontWeight: 'bold'
                            }
                        }
                    }]
                });
                link.addTo(self._jointPN);
                state.jointNext[event] = link;
            })
        });

        //now refresh the visualization
        self._jointPaper.updateViews();
        self._decoratePetriNet();
    };

    PNWidgetWidget.prototype.destroyPetriNet = function () {

    };

    PNWidgetWidget.prototype.fireEvent = function (event) { //this is where you change the marking
        const self = this;
        const current = self._webgmePN.states[self._webgmePN.current];
        const link = current.jointNext[event];
        const linkView = link.findView(self._jointPaper);
        //animation
        linkView.sendToken(joint.V('circle', { r: 10, fill: 'black' }), {duration:500}, function() {
           self._webgmePN.current = current.next[event];
           self._decoratePetriNet();
        });
    };
    // will have similar function to ^^ to change the marking
        //pass in the ID of the transition to be fired, check all the incoming places, subtract one token, and add one token to all the outgoing places
        
    // after each fire event, when decorate machine for ex is called, all that's needed to do is change the color of the transition that is firing
    // calling deocrateMachine in each fireEvent
    // in the handling of the click, you want to decide whether you can actually make that transition

    //also need to use resetMachine function 
        // want to store the initial marking and reset the machine this way

    // create descriptor for how you want this to work

    // after fire event is called and the objects are initialized, need to check which nodes are fireable

    PNWidgetWidget.prototype.resetPetriNet = function () {
        this._webgmePN.current = this._webgmePN.init;
        this._decoratePetriNet();
    };

    PNWidgetWidget.prototype._decoratePetriNet = function() {
        const pn = this._webgmePN;
        Object.keys(pn.nodes).forEach(nodeId => {
            pn.nodes[nodeId].joint.attr('body/stroke', '#333333');
        });
        pn.nodes[pn.current].joint.attr('body/stroke', 'blue');
        pn.setFireableEvents(Object.keys(pn.nodes[pn.current].next));
    };

    PNWidgetWidget.prototype._setCurrentState = function(newCurrent) {
        this._webgmePN.current = newCurrent;
        this._decoratePetriNet();
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    
    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    PNWidgetWidget.prototype.destroy = function () {
    };

    PNWidgetWidget.prototype.onActivate = function () {
        this._logger.debug('PNWidgetWidget has been activated');
    };

    PNWidgetWidget.prototype.onDeactivate = function () {
        this._logger.debug('PNWidgetWidget has been deactivated');
    };

    return PNWidgetWidget;
});
